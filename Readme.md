
---

# 2024-07-24

## AJAX(Asynchronous Javascript And XML)
- AJAX란, JavaScript의 라이브러리중 하나이며, HTML, CSS, 자바스크립트, DOM, XML 등 기존에 사용되던 여러 기술을 함께 사용하는 새로운 개발 기법입니다.
- 브라우저가 가지고있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법이며, JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술입니다.
- 즉, 쉽게 말하자면 자바스크립트를 통해서 서버에 데이터를 요청하는 것입니다.
- 참고: https://daegwonkim.tistory.com/445  
    https://hstory0208.tistory.com/entry/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%86%B5%EC%8B%A0-Ajax%EC%99%80-Axios%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90


## PUT & PATCH 메소드
PUT과 PATCH 모두 데이터를 수정할 때 사용한다.  
하지만 꼭 수정할 때 PUT 또는 PATCH를 사용할 필요는 없다.  
일반적으로 POST를 등록/수정에 주로 사용한다.  
- PUT: 기존의 모든 것을 수정
- PATCH: 일부 부분적인 수정


## 와일드카드
와일드카드를 사용한 라우팅 메서드는 가장 아래에 선언해야 한다.  
그렇지 않으면 aid = 1 = delete?aid=1 이들 모두 같다고 인식한다.  

Ex)
- http://localhost:3000/api/articles/1
- http://localhost:3000/api/articles/delete?aid=1

와일드 카드는 주소체계가 같으면 뒤쪽을 값으로 인식한다.


## 미들웨어
응답 전에 미들웨어를 먼저 실행하게 하여 특정 로직을 태운다.  
라우팅 메소드를 호출할 때, 호출 주소와 콜백함수 사이에 미들웨어를 추가한다.  
-> 미들웨어를 통해 로그인 여부를 체크할 수 있다.

참고: https://velog.io/@unyoi/%EC%9D%B8%ED%94%84%EB%9D%BC-%EB%BF%8C%EC%8B%9C%EA%B8%B01-%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%85%90%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

## EJS
- 라우팅 메소드에서 view에 전달된 데이터 출력하려면 =을 쓴다.  
-> <%=데이터 속성명%>

---

# 2024-07-25

주의 !  
views/.ejs 파일의 <%%> 구문은 백엔드 코드  
routes/.js 파일의 <script> 구문은 프론트엔드 코드


## 시맨틱 태그(Semantic Tag)
- html에서 페이지가 어떤 내용의 영역인지 유추할 수 있도록 태그 이름에 의미를 부여한다.
    사실 div 태그로 해도 상관없다.

- 똑같은 div로 하는 것보다 시맨틱 태그를 사용하는 것이 검색 엔진을 최적화할 수 있다.
    Ex) nav, main, article


## view 화면 컴포넌트 재사용
- Include 방식
    - 각각 물리적인 파일로 존재한다.
    - html 태그 영역, script 태그 영역, css 영역은 여전히 중복된다.

- 레이아웃
    - 레이아웃에는 실제 컨텐츠를 제외한 공통 부분만 포함한다.
    - 레이아웃에서 <%-  %> 태그를 이용해 통합한다.
    - <body>, <meta>(검색 엔진 최적화), <style>, <script> html 태그를 적용할 수 있다.

-> 기본적으로는 레이아웃 기술을 사용하고, 레이아웃을 적용해도 중복되는 부분은 부분적으로 Include 파일로 따로 뺀다.

---

# 2024-07-26

## DBMS
데이터 관리 SW 시스템

### RDBMS
- RDBMS 특징
    - 결함이 없는 데이터를 안정적으로 영구적으로 관리하는 것이 주요 목적
    - 데이터 수가 많으면 RDBMS는 속도가 떨어진다.
    - DB 서버 복제가 오래 걸린다.
    - 속도보다 무결성 데이터 수집을 목적으로 한다 !
    - Constraints(제약사항)을 이용하여 무결성 데이터를 수집한다.(데이터에 결함이 있다면, 에러를 발생시킨다.)
    - Ex) MySQL, MariaDB(MySQL과 유사), PostgreSQL
- RDBMS 구조
    - Databases - Tables - Rows - Columns
    - TABLE간의 관계 기반 정형 데이터 관리
    - TABLE의 관리 항목은 사용자 관리 항목(제목, 내용 등)과 시스템 관리 항목(ID, 등록일시, IP 등)으로 나뉜다.

### NoSQL
- 관계형 데이터베이스의 한계를 극복
- 빠른 응답 속도, 높은 가용성(사용자가 늘어남에 따라 자원(DB 서버)을 늘렸다 줄였다 가능), 확장성(DB 서버를 실시간으로 복제해서 확장하는 것이 자유롭다. 
    -> Scale-Up:단일 서버 CPU/메모리 추가, Scale-Out:서버를 추가), 가용성(백업(스탠바이)서버 없이 사용 중에 실시간으로 DB 서버가 늘릴 수 있다.)
- 데이터 양이 많고(빅데이터), 데이터 구조가 정해져있지 않은 경우 NoSQL을 사용한다.
- 정형 데이터 방식으로도, 비정형 데이터도 관리할 수 있다.
- 실시간으로 확장이 가능하다.
- 트래픽을 예측할 수 없는 경우 사용된다.

- Document DB
    Ex) MongoDB
- KEY-VALUE DB
    Ex) REDIS

---

# 2024-07-29

## MySQL
- Schema(=Database)
- Character Set은 utf8mb4(utf8에 이모지를 포함한 최신 버전)
- collation은 unicode_ci를 선택하면 정렬을 할 수 있다.

### MySQL 데이터 유형
- 문자형
    - CHAT(고정길이형)
        - 문자열 고정길이는 해당 길이만큼 사이즈를 사용한다.
        - 실제 데이터가 안들어가도, 데이터 길이가 고정된 형태 데이터 입력
        - 길이가 정해져 있는 데이터를 사용할 때 CHAR를 사용한다.
    - VARCHAR(가변길이형)
        - 문자열 가변길이
        - 알파벳 한 글자: 1byte, 유니코드 한 글자: 2byte
    - TEXT
        - 1000자리 이상의 긴 문자열

### MySQL TABLE 제약조건
    - PK(Primary Key)
    - NN(Not Null)
        NULL은 Data가 입력 안된 초기 상태, 공백 문자는 값이 들어가 있다.
    - UQ(Unique Key)
        Primary Key는 Unique Key
    - ZF(Zero Fill)
        남는 공간은 0으로 채운다.
    - AI(Auto Increment)
        자동 증가

## Model
데이터의 구조를 프로그래밍 언어로 표현한 클래스  
물리적인 테이블을 백엔드에서 제어하기 위함

- Data Model: DB의 TABLE과 1대1 매핑된다.
- View Model: 화면의 구조가 기준
- DTO Model: 여러 모델의 데이터를 하나의 모델로 준다.

## ORM
모델과 물리적인 TABLE을 1대1 매핑해 모델을 통해 관리한다.  
ORM 프레임워크에서 동적으로 SQL 쿼리를 만들어준다.

## Code First & Model First
코드로 모델을 만들고, DB를 적용한다.  
새로운 프로젝트를 만들 때 사용한다.
- Database First
    - 만들어진 DB를 바탕으로 코드에 적용한다.
    - 이미 운영 중인 시스템에 사용한다.

## /model/index.js
index.js는 물리적인 데이터베이스 그 자체를 가리킨다.

---

# 2024-07-31

사용자 사이트는 UI/UX도 좋아야 하고, 디자인도 최신 트렌드를 따라가기 위해 프론트와 백엔드를 나눠서 개발하지만,  
관라지 사이트는 디자인을 신경 쓸 필요가 없기 때문에, 백엔드에서 모든 것을 개발하기도 한다.

## Socket.io 모듈
### 클라이언트 -> 서버로 전송한 메시지 수신
- on 메소드
현재 접속되어 있는 클라이언트로부터 메시지를 수신하려면 on 메소드 사용
    - io.on
        - 'connection' : socket.io의 기본 이벤트, 사용자가 웹사이트에 접속하면 자동으로 발생하는 이벤트
    - socket.on
        - 해당 클라이언트에서 메세지를 보낸다.
### 서버 -> 클라이언트로 메시지 전송
- emit 메소드
    - io.emit
        - 서버가 현재 접속해있는 모든 클라이언트에게 이벤트 전달
        - io.emit은 연결된 모든 클라이언트를 대상으로 한다.
            -> 따라서 sender인 socket에 해당되는 client에게도 전달된다.
    - socket.emit
        - 서버쪽에서 event를 발생시키는 함수
        - 서버에서 이벤트 발생시키면 클라이언트 페이지의 해당 이벤트 리스너에서 처리
        - 해당 소켓을 통해 클라이언트에게 메시지 전송
        - sender인 socket의 클라이언트는 제외한다.

참고: https://velog.io/@rzee/Node.js-Socket.io-%EB%AA%A8%EB%93%88-.emit-.on  
https://velog.io/@nittre/NodeJS-io.emitio.sockets.emit%EA%B3%BC-socket.broadcast.emit%EC%9D%98-%EC%B0%A8%EC%9D%B4


## CORS
- 같은 서버 도메인이 아닌 다른 도메인에서 데이터를 호출할 때, 차단되어 CORS 이슈가 생긴다.
    -> 동일 출처 원칙을 위반
- 허용된 도메인에 대해서 데이터/소캣 기능을 제공할 수 있도록 CORS 설정이 필요하다.
- 데이터를 제공하는 도메인과 사용하는 도메인이 다르면, 시스템 상에서 차단한다.
- 도메인을 등록하면 사용할 수 있다.
- restful, 채팅 서버에서 CORS 이슈가 많이 발생한다.

## JWT
JSON 형식의 데이터를 암호화해 놓은 토큰

- 토큰을 까보면 JSON 데이터가 들어있다.
- 토큰에 담겨져있는 데이터는 바꿀 수 없다.
    -> 바꾸면 깨져버리기 때문에 안전하다.
- JWT 토큰의 형식
    - HEADER: 토큰 종류와 해시 알고리즘 정보 제공
    - PAYLOAD: 토큰으로 저장하는 실제 데이터인 JSON 데이터를 인코딩하여 저장하는 영역
    - SIGNATURE: 일련의 문자열로 서버에서 발급해준 특정 문자열로 시그니처 값을 통해서 사버의 값과 비교해 토큰이 변조되었는지 여부를 확인할 수 있는 값 설정.
- PAYLOAD 영역에 들어있다.
- 토큰을 만들 때도 인증키가 필요하고, 까볼 때 만들때 사용했던 인증키가 필요하다.(양방향 암호화)

### Q, JWT 토큰을 왜 쓰는가?
- 용도
    이기종 시스템 간의 데이터 상호교환을 통한 시스템 통합수단으로 사용
- 오리지널 데이터를 변조없이 주고 받을 수 있다.
- JWT토큰은 기본적으로 변조 불가능하다.
- 난독화/복호화 사용이 간편해 각종 시스템간 데이터 교환 표준 포맷으로 사용된다.

---

# 2024-08-01